-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.


-- Type: role

-- DROP TYPE IF EXISTS public.role;

CREATE TYPE public.role AS ENUM
    ('maker', 'taker');

ALTER TYPE public.role
    OWNER TO postgres;

-- Type: token_scope

-- DROP TYPE IF EXISTS public.token_scope;

CREATE TYPE public.token_scope AS ENUM
    ('sudo', 'read', 'write');

ALTER TYPE public.token_scope
    OWNER TO postgres;

-- Type: category_names

-- DROP TYPE IF EXISTS public.category_names;

CREATE TYPE public.category_names AS ENUM
    ('Temperatur', 'CO2', 'Luftfeuchtigkeit', 'Luftdruck', 'Unit Counter', 'LautstÃ¤rke');

ALTER TYPE public.category_names
    OWNER TO postgres;

-- Type: connection_types

-- DROP TYPE IF EXISTS public.connection_types;

CREATE TYPE public.connection_types AS ENUM
    ('http', 'ttn', 'other');

ALTER TYPE public.connection_types
    OWNER TO postgres;

---------------------
---------------------
---------------------
---------------------
-- public tables
---------------------
---------------------
---------------------


CREATE TABLE IF NOT EXISTS public.categories
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name category_names NOT NULL,
    description character varying(200) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT categories_pkey PRIMARY KEY (id),
    CONSTRAINT category_name_unique UNIQUE (name)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.categories
    OWNER to postgres;

ALTER TABLE IF EXISTS public.categories
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.categories TO anon;

GRANT ALL ON TABLE public.categories TO authenticated;

GRANT ALL ON TABLE public.categories TO postgres;

GRANT ALL ON TABLE public.categories TO service_role;

--------------------- START user_profiles ---------------------
CREATE TABLE IF NOT EXISTS public.user_profiles
(
    id uuid NOT NULL,
    name character varying(36) COLLATE pg_catalog."default" NOT NULL DEFAULT (uuid_generate_v4())::text,
    display_name character varying(50) COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
    role role DEFAULT 'maker'::role,
    url character varying(100) COLLATE pg_catalog."default",
    description character varying(500) COLLATE pg_catalog."default",
    CONSTRAINT user_profiles_pkey PRIMARY KEY (id),
    CONSTRAINT name_unique UNIQUE (name),
    CONSTRAINT name_length_min_3_check CHECK (char_length(name::text) >= 3),
    CONSTRAINT special_character_check CHECK (name::text ~* '^[a-zA-Z0-9_-]*$'::text)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.user_profiles
    OWNER to postgres;

ALTER TABLE IF EXISTS public.user_profiles
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.user_profiles TO anon;

GRANT ALL ON TABLE public.user_profiles TO authenticated;

GRANT ALL ON TABLE public.user_profiles TO postgres;

GRANT ALL ON TABLE public.user_profiles TO service_role;
CREATE UNIQUE INDEX IF NOT EXISTS user_name_case_insensitive
    ON public.user_profiles USING btree
    (lower(name::text) COLLATE pg_catalog."default" ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Allow individual delete access"
    ON public.user_profiles
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = id));
CREATE POLICY "Allow individual insert access"
    ON public.user_profiles
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = id));
CREATE POLICY "Allow individual update access"
    ON public.user_profiles
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = id));
CREATE POLICY "Allow read access for authenticated on public users table"
    ON public.user_profiles
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));
CREATE POLICY "Allow read access on public users table"
    ON public.user_profiles
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'anon'::text));



--------------------- START sensors ---------------------

CREATE TABLE IF NOT EXISTS public.sensors
(
    created_at timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    external_id character varying(36) COLLATE pg_catalog."default",
    name character varying(50) COLLATE pg_catalog."default",
    description character varying(500) COLLATE pg_catalog."default",
    connection_type connection_types NOT NULL DEFAULT 'http'::connection_types,
    location character varying(50) COLLATE pg_catalog."default",
    longitude double precision,
    latitude double precision,
    altitude double precision,
    category_id integer NOT NULL,
    icon_id integer,
    user_id uuid NOT NULL,
    CONSTRAINT sensors_pkey PRIMARY KEY (id),
    CONSTRAINT sensors_category_id_fkey FOREIGN KEY (category_id)
        REFERENCES public.categories (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT sensors_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.user_profiles (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT name_length_min_3_check CHECK (char_length(name::text) >= 3)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.sensors
    OWNER to postgres;

ALTER TABLE IF EXISTS public.sensors
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.sensors TO anon;

GRANT ALL ON TABLE public.sensors TO authenticated;

GRANT ALL ON TABLE public.sensors TO postgres;

GRANT ALL ON TABLE public.sensors TO service_role;
CREATE POLICY "Allow individual delete access"
    ON public.sensors
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY "Allow individual insert access"
    ON public.sensors
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((auth.uid() = user_id));
CREATE POLICY "Allow individual update access"
    ON public.sensors
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((auth.uid() = user_id));
CREATE POLICY "Allow read access for authenticated on public sensors table"
    ON public.sensors
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));
CREATE POLICY "Allow read access on public sensors table"
    ON public.sensors
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'anon'::text));


--------------------- END sensors ---------------------

CREATE TABLE IF NOT EXISTS public.records
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    recorded_at timestamp with time zone NOT NULL,
    measurements double precision[],
    sensor_id integer NOT NULL,
    CONSTRAINT records_pkey PRIMARY KEY (id),
    CONSTRAINT records_sensor_id_fkey FOREIGN KEY (sensor_id)
        REFERENCES public.sensors (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;


ALTER TABLE IF EXISTS public.records
    OWNER to postgres;

ALTER TABLE IF EXISTS public.records
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.records TO anon;

GRANT ALL ON TABLE public.records TO authenticated;

GRANT ALL ON TABLE public.records TO postgres;

GRANT ALL ON TABLE public.records TO service_role;
CREATE POLICY "Allow read access for authenticated on public records table"
    ON public.records
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));
CREATE POLICY "Allow read access on public records table"
    ON public.records
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'anon'::text));

CREATE TABLE IF NOT EXISTS public.auth_tokens
(
    nice_id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    id text COLLATE pg_catalog."default" NOT NULL,
    description character varying(200) COLLATE pg_catalog."default" NOT NULL,
    scope token_scope NOT NULL DEFAULT 'sudo'::token_scope,
    user_id uuid NOT NULL,
    salt character varying(255) COLLATE pg_catalog."default" NOT NULL DEFAULT ''::character varying,
    CONSTRAINT auth_tokens_pkey PRIMARY KEY (id),
    CONSTRAINT auth_tokens_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES public.user_profiles (id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.auth_tokens
    OWNER to postgres;

ALTER TABLE IF EXISTS public.auth_tokens
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.auth_tokens TO anon;

GRANT ALL ON TABLE public.auth_tokens TO authenticated;

GRANT ALL ON TABLE public.auth_tokens TO postgres;

GRANT ALL ON TABLE public.auth_tokens TO service_role;
CREATE POLICY "Allow individual delete access"
    ON public.auth_tokens
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((auth.uid() = user_id));





--- policies
CREATE POLICY "Allow read access on public categories table"
    ON public.categories
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'anon'::text));
CREATE POLICY "Allow read access on public categories table authorized"
    ON public.categories
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((auth.role() = 'authenticated'::text));


--------------------- START functions ---------------------


CREATE OR REPLACE FUNCTION public.get_users_alphabetically(
	)
    RETURNS SETOF user_profiles
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
   RETURN QUERY
   SELECT * FROM public.user_profiles ORDER BY lower(name);
END;
$BODY$;

ALTER FUNCTION public.get_users_alphabetically()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.get_users_alphabetically() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.get_users_alphabetically() TO anon;

GRANT EXECUTE ON FUNCTION public.get_users_alphabetically() TO authenticated;

GRANT EXECUTE ON FUNCTION public.get_users_alphabetically() TO postgres;

GRANT EXECUTE ON FUNCTION public.get_users_alphabetically() TO service_role;

CREATE OR REPLACE FUNCTION public.delete_user(
	)
    RETURNS void
    LANGUAGE 'sql'
    COST 100
    VOLATILE SECURITY DEFINER PARALLEL UNSAFE
AS $BODY$
delete from public.user_profiles
where id = auth.uid();
delete from auth.users
where id = auth.uid();
$BODY$;

ALTER FUNCTION public.delete_user()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.delete_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.delete_user() TO anon;

GRANT EXECUTE ON FUNCTION public.delete_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.delete_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.delete_user() TO service_role;

CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$
 begin
insert into public.user_profiles (id)
values (new.id);
return new;
end;
$BODY$;

ALTER FUNCTION public.handle_new_user()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO service_role;

CREATE OR REPLACE FUNCTION public.handle_deleted_user()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$
 begin
delete from public.user_profiles
where id = old.id;
return old;
end;
$BODY$;

ALTER FUNCTION public.handle_deleted_user()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_deleted_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_deleted_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_deleted_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_deleted_user() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_deleted_user() TO service_role;

CREATE OR REPLACE FUNCTION public.check_external_id()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
AS $BODY$
 begin if new.connection_type = 'ttn' then if new.external_id is null then raise exception 'external_id cannot be null when connection type is %',
new.connection_type;
end if;
end if;
return new;
end;
$BODY$;

ALTER FUNCTION public.check_external_id()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.check_external_id() TO authenticated;

GRANT EXECUTE ON FUNCTION public.check_external_id() TO postgres;

GRANT EXECUTE ON FUNCTION public.check_external_id() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.check_external_id() TO anon;

GRANT EXECUTE ON FUNCTION public.check_external_id() TO service_role;



--------------------- START triggers ---------------------

CREATE TRIGGER on_sensors_external_id_check
    BEFORE INSERT OR UPDATE
    ON public.sensors
    FOR EACH ROW
    EXECUTE FUNCTION public.check_external_id();